// selection sort

for 0 - n-1
	min = i
	for j = i+1 - n
		if(arr[j] < arr[min])
			min = j
	temp = arr[min]
	arr[min] = arr[i]
	arr[i] = temp


// insetion sort
for 0 - n
	key = arr[i]
	j = i -1
	while(j >= 0 && arr[j] > key){
		arr[j+1] = arr[j]
		j--;
	}
	arr[j+1] = key

// bubble sort
for 0  - n-1
swap = false
	for o - n - i -1
		if(arr[j] > arr[j+1])
			arr[j] arr[j+1] = arr[j+1] arr[j]

	if swap == false
		break


// quicksort
pi = qsort(arr, low, high)
 sort(arr, low, pi -1)
 sort(arr, pi+1, high)


qsort (arr, low, high){
	i = low - 1;
	pvot = arr[high]
	for low - high
		if(arr[j] < pvot)
			i++
			arr[i], arr[j] = arr[j], arr[i]

	arr[i+1], arr[high] = arr[high], arr[i+1]
	return i+1
} 


// merge sort
m = l + h /2
 sort(arr, l, m)
 sort(arr, m+1, high)
 merge(arr,l, m, h)

merge(arr, l, m, h){
	n1 = m - l, n2 = h - m+1

	left [n1], right[n2]
	i = 0, j = 0, k = l

	while(i < n1, j < n2){
		if(left[i] <= right[j])
			arr[k] = left[i]; i++, 
		else
			arr[k] = right[j]; j++, 
		
		k++
	}

	while i < n1
		arr[k] = left[i]
	while j < n2
		arr[k] = right[j] 
	arr[k]

}



